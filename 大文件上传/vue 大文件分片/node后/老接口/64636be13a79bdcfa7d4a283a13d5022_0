# 1 九宫切图控件

> 这个功能的提出最初是由设计师提出的，设计师认为为了更好的对图片进行一个控制，所以提出了这么一个需求，这一块实际上是分为了两个组协同开发的，一是我们开发组，二是组件组，我需要做的就是像组件组提供必要的数据，由他们负责写自定义组件进行渲染，我负责整个控件的开发，实际上我们的组件全部在一个单独的项目中，叫做GUI，需要使用软链的形式结合主体项目进行开发。
>
> 首先需要根组件同学约定传输的数据类型与格式，传输的类型为pointNineIamge，数据格式为图片地址加上四个坐标百分比，分别对应四根线的位置pointNineIamge：{url，top，bottom，left，right}，这里特别注意到了一点，例如横着的两条线当下面的那条线距离顶部的百分比小于上面的那条线的百分比的时候，下面那条线就变为了上面那条线，具体实现我将这个控件单独从图片上传组件中抽离出来，进一步降低对代码的入侵程度也为了后续更好的维护，我将这个功能分为了两部分，一部分是弹框，一部分是线组件，具体使用useReducer进行线比例的计算与逻辑的处理，使用React.memo（缓存整个组件的prop数据）进行性能上的优化通过注册mousemove事件进行线的移动，最后通过提交将数据交给组件方，当然我自己也写了一个自定义组件用于测试功能是否完成，我的任务就是确保组件方能够正确收到数据即可。最后设计师是挺满意的。

# 2 隐藏卸载

> 全局的隐藏卸载无法更精准的控制指定面板的隐藏或者卸载，将隐藏卸载作为动态面板的配置项交由用户手动指定哪些地方进行隐藏卸载，提升用户体验，为了更好的照顾弱设备用户的体验，减少内存使用，功能开启后进入预览或者发布也，动态面板的切换由隐藏转变为卸载。
>
> 由于此前已存在全局的隐藏卸载，我只需要负责将全局的隐藏卸载功能下放到具体的动态面板组件中，新增一个单选框用以控制当前动态面板是否开启隐藏卸载，同时处理局部隐藏卸载与全局隐藏卸载冲突时的优先级问题，当功能开启时增加传递到组件的动态面板的参数，当识别到有此参数的时候优先按照此参数而非全局的隐藏卸载参数。经过改进后客户群中的客户好评连连



# 3 定制化服务

> 某个用户的独立部署版本中希望删除预览加载时候的骨架屏与新增一条后路方法将当前展示的组件全部替换为默认数据，以便更好的进行组件参数的配置此功能完全交由我进行开发。
>
> 首先找到用户具体的版本包，在我们的gitlab上存放，将分支与对应的node版本切换后检查骨架屏的位置，经检查后发现骨架屏是写成了一个高阶组件，预览界面外层包裹了该高阶组件，类似于插槽的形式，于是只需要将外层的高阶组件去掉即可，然后是静态模式功能，由于是后路方法，并没有要求产品化，按照客户意愿，当地址栏参数多一个useStatic的时候，将全部组件的数据转换为默认数据，我这里是将redux里根据组件id找到对应的组件配置信息，全部替换为初始数据，由于是在地址栏中，回车后页面会进行一个重新渲染，自然而然的就可以应用上静态数据，后续产品认为此功能需求率高，后续做成了产品化，变为了一个具体的配置项，不过后续由我的同事进行的开发。

# 4 申请试用表单

> 为了更好的推广尊享版产品，收集用户体验欲望，于是在申请试用表单上新增了尊享版试用的弹窗表单，讲收集的需求交由后台系统收集由后台操作人员进行咨询与开通服务
>
> 于是由我负责这个表单的开发与后端人员的对接。
>
> 由于此功能在一个弹窗上弹出另一个弹窗，为了避免后续维护困难，我选择了单独写成一个组件来降低代码的耦合度与入侵程度，借助组件库的弹窗组件与FORM表单组件，当用户没有选择试用的产品时为提交为禁用状态，通过枚举的方式书写固定的产品名称，通过Form.useWatch去监视每个输入框的变化，由于两个项目使用的antd组件库版本不同，开发的时候出现了一些错误，来更新禁用按钮，逻辑上并无什么特别要注意的，对我来说难点在于根据设计图的需要做出指定的局部样式的覆盖， 借助global去覆盖全局样式，当然需要限制在该组件内部。



# differ白屏优化

背景 思考 解决方案 结果

> 排除网络因素的情况下结合浏览器的性能工具与性能指标分析发现
>
> 首屏渲染的dom内容较多，做了很多的echat图标进行数据汇报，所以一开始考虑了使用骨架屏的方式，但是仍然是治标不治本，后续又考虑了ssr的方式，SSR虽然能够很有效的解决此类问题，但是压力会转移到服务器方，同时考虑成本的话并没有太大必要，SSR其实我考虑最好还是用在SEO优化去使用于是我想到了react16以后提出fiber架构的那种解决方案，能否根据组件优先级的不同去进行分帧渲染
>
> 与之类似的又requistIdelcallback与requestAnimationFarme，但是考虑到如果浏览器没有空闲时间的话，那么requistIdelcallback就形同虚设，而animationFarme是在浏览器重新渲染之前执行回调函数，将长任务分为一个个的短任务，当然由于分帧，实际的加载时间可能会变长，但是给用户的体验是很好的，于是就写了这么一个differ函数。根据任务的优先级结合v-if来判断当前帧是否需要渲染该组件，这样对代码的入侵性最低，也降低了FCP与LCP
>
> 我们可以利用vue的响应式数据的更新机制，每一帧更新一个响应式数据的值，我们可以设置一个不重复的自增的值，每一帧跟新一个响应数据的值，将长任务分解成一个个小任务
>
> 有关性能指标
>
> FCP：FCP 是指浏览器首次渲染来自 DOM 的内容的时间
>
> LCP：LCP 是指视窗内最大的可见内容元素被完全渲染的时间点
>
> CLS：CLS 衡量的是页面在加载过程中发生的视觉稳定性
>
> INP：INP 衡量的是从用户首次与页面交互到浏览器对该交互做出响应的时间
>
> TTFB:  TTFB加载第一个字节所需要的时间

# 无感刷新

> 为了提升用户体验，保证用户在长时间待机情况下的登录信息不丢失，要在用户无感知的情况下维持登录状态，那么通常就需要实现无感刷新了，那么无感刷新一般存在两种解决方案，但是他们都是建立在单点登录的去看下的，否则毫无意义，而单点登录就是SSO，即定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统，SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过`认证中心`，`认证中心`将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被`认证中心`授权以后，会建立一个局部会话，在一定时间内可以无需再次向`认证中心`发起认证，
>
> 一开始考虑使用session+cookie的情况，这种情况对用户的控制更强一些，将用户信息存到服务器的session中只给客户端sid存到cookie中，那么用户每次请求受限资源时将sid带入，服务器去请求认证中心进行验证，得到认证中心的验证后将受限资源返回，但是必须要考虑到后续如果访问量剧增，那么服务器与认证中心就需要不断通信，那么认证中心与服务器都需要进行扩容，成本较大，但用户控制粒度比较强，如果希望强制下线用户只需要删除session中的对应数据即可。
>
> 而另一种是单token和双token，token又称json web token ，采用jwt格式，header，payload，singer三步分组成，header记录加密的算法，密钥等，header记录相关信息过期时间等，singer则是对前两部分的加密，三种的加密结果共同组成token，所以一个经过验证的token是可以信任的，那么单token的情况下服务器不需要记录任何东西，只需要生成安全切不可被篡改的token在客户端存储即可，下次请求时将token带过去，子系统可以自行进行认证（比如子系统与认证中心交换一下密钥，使得子系统自己就可以进行验证）这样就无需子系统像认证中心频繁请求，后续扩容也只需要扩容子系统即可，这是一种分布式的认证方式，而弊端在于单token因为只要一个token，时间长则对用户的控制力削弱，时间短则影响用户体验。
>
> 双token情况下使用两个token，一个token用于身份验证时间过期较短，另一个token时间较长，用于更新验证身份的token，且刷新token只有认证中心能够识别，也就是希望用户每隔一段时间向认证中心请求一次，这样可以增强认证中心的控制力度，如果用户存在违规操作，虽然无法直接让其下线，但一段时间后用户需要来换token此时拒绝向用户替换即可

# 权限管理

> 后台一般都需要进行权限的管理与分配，以保证不同的人员拥有不同的权限，而前端的权限管理呢主要分为三个级别，页面级，组件级，函数级，他们对代码的入侵程度各不相同，其中页面级对代码的入侵程度最低，几乎被路由守卫给全部囊括，一般存在两种解决办法，第一种，直接在路由meat里面写上具体那些职位的人允许进入此路由，在登陆后获取对应的身份信息时，进行页面跳转时去判断当前跳转的路由是否允许该权限的人进入，否则跳转到404，第二种则是动态生成路由，将路由分为常态路由和动态路由，常态路由写在路由表中，后登录后得到用户拥有的权限对应的动态路由表，通过addrouter动态生成。我才用的是第二种。这样可以避免没有权限的人看不到对应的转跳按钮
> 组件级别的权限管理对代码就存在一定的入侵性了
>
> > 组件级别的权限控制由于无法在路由层面处理，只能够判断有什么权限是否要展示或者禁用等等，这样势必会造成代码要写一堆权限鉴定的判断逻辑，从而使的权限判断影响组件开发。
> >
> > 这里只讲 根据权限是否展示某些组件
> >
> > 方法一 麻烦的办法，针对需要权限鉴定的组件使用v-if进行判断，每个页面都获取用户的权限然后根路由表里面定义的白名单进行对比
> >
> > 方法二 封装自定义指令，同样需要在路由表里定义白名单，例如某个角色在这个页面拥有的按钮权限为什么，根据这个权限禁用或者不显示一批组件，然后封装自定义指令，拿到当前页面组件的白名单，然后根据白名单与当前登录的人的身份信息权限进行对比，如果没有则进行具体的限制操作例如禁用或者移除当前dom，这样的话后续我们在使用需要进行权限管理的地方使用自定义指令即可，他会帮我门进行处理
> >
> > 方法三 封装组件
> >
> > 通过封装一个组件，将需要控制权限的组件利用插槽传递到组件里面，在组件内部进行权限的验证来判断同时判断对没有权限的组件进行那种操作。
> >
> > 组件内部拿到当前用户的权限，同时传入该组件需要的权限，在组件内部进行判断插槽是否需要显示

# 大文件上传

>  普遍方案就是文件分片上传，将一个大事务划分为多个小事物，降低失败的风险，由于采用了BFF层，前端只跟FBB层服务器打交道，由中间层间接的给服务器打交道（用来处理数据不一致）。那么前端的文件上传传到中间层 中间层进行存储，中间层将文件存储的地址与名称交给后端（后端不保存文件，只保存地址），前端需要解决的其实只有两个问题，1是文件切片（基于cpu内核进行分片，一个核心分多少个任务，然后再交给主线程），2是并发上传（promise队列，每次最多同时发送六个，借助对同一域名最多存在六条连接的特点）
>
>  首先要保证不重复上传，为了保证不重复上传，我们对每一个分片采用md5的算法生成hash，上传服务器的时候第一次请求不携带分片数据，而是携带分片的hash值，去服务器进行判断是否存在，如果不存在第二次请求才会带过去具体的分片数据与hash再次验证，针对整个文件也是如此，根据每个分片的hash计算整个文件的hash。看看整个文件是否已经上传过了，上次上传上传到了哪里。
>
>  但是得到整个文件的hash势必要先计算出其他分片的hash然后才能得出整个文件的hash，于是这里存在两种做法，我们假设大多数文件都是没有进行上传过的，
>
>  分片无非就是对file文件进行slice按照字节进行切片，成为一个blob（数据的大小与类型）使用fileReader去读具体的内容，实际上我们需要fromData上传，每一个切片的包含 blob，分片起始字节，结束字节，hash，index索引
>
>  1 先进行分片，然后计算出每个分片的哈希值，得到全部哈希值后计算整体哈希，然后进行上传(先上传整体哈希进行判断)，那么用户的体验就是，进度条先卡20秒（计算哈希）如果之前没有上传过，则开始慢慢上传，如果之前已经上传过了，则会直接跳到对应上传过的进度，用户体验并不是很好
>  另一种无需等待整体哈希的计算结果，分片后立即上传，即便存在刚开始的无效请求，但由于第一次上传携带是2
>
>  2 hash只需要进行判断，所以即便是无效请求损耗也不大，一边分片一边上传，然后分片哈希计算完成后在补上整体哈希，那么这种情况就是，服务器先进行分片，然后一个分片计算一个哈希然后开始上传，等全部分片和哈希计算完后，计算整体哈希，然后补充整体哈希由服务器判断是否之前上传过，如果没有则继续进行上传，如果已经上传过了则直接跳到上传过的进度，那么用户的体验就是，点击上传之后 进度条一点点的在动，然后突然上传完成（如果之前上传过的话）或者调整剩余需要上传的文件。
>
>  那么前后端协调的时候，首先就应向后端发送创建文件协议，前端将文件的部分信息包括文件总体大小，名称等给到服务器，后续服务器最重要的需要返回一个token，来告诉后续上传的切片属于哪一个文件
>
>  整体与切片的哈希校验：校验切片比较简单，只需要我们带过去hash以及创建文件协议产生的token即可，服务器会告诉我们当前切片是否已经上传了。针对整体哈希校验，我们需要带上整个文件的hash以及token，服务器需要告诉我们，当前文件是否已经上传完毕，如果没有，还需要编号从多少到多少的分片。如果文件已经上传，则给我门文件url地址
>
>  分片数据上传协议：带过去token，切片编号，编号的hash，此次上传的字节数，文件类型（formData需要使用formdata构造器，octet-stream二进制格式），
>
>  我们在上传前就需要和后端约定好，我们上传携带的数据，包括总体文件大小，切片大小（字节数），每一片的hash，整体文件的hash，切片编号，如果之前已经上传过了等到整体哈希补充完成后，服务器需要响应还剩下那些切片没有上传（服务器那边计算，得到一个包括起始和结束字节的二维数组）后续客户端根据这个数组调整剩下的切片范围
>
>  那么后端考虑的问题，首先是如何区分每次上传的文件
>
>  这个解决，我们使用uuid配合jwt生成token即可
>
>  然后如何保证分片不重复，分片跨文件唯一，并且永不删除
>
>  我们认为呢，bff层用来存储具体的分片，而后端服务器记录每一个文件对应的切片的地址，后续访问文件时，读取所有的分片文件，开启可读流，直接输出到网络i/o



# 网页复制成图片至剪贴板

> 考虑到针对商品数据列表如果需要向外部分享数据，如果以纯文本的形式或者以截图的形式会显得很麻烦，于是我想到了excel中复制一块数据在微信进行粘贴的时候会以图片的形式出现，很大程度上会方便用户进行分享。传统的Clipboard API只能针对文本写入粘贴板，要想实现以图片的形式粘贴到剪切板中，需要将dom转换为canvas。
>
> 那么大概需要进行这几步，获取区域的dom元素，将dom元素转换为canvas，将canvas转换为blob，将blob写入到剪切板，整体流程大概是这样，但是里面存在着很多细枝末节的小问题需要处理
>
> 那么dom元素转换为canvas是一个比较复杂的工作，需要对浏览器的渲染原理比较了解。包括但不限于解析dom树提取需要绘制的节点，加载和处理图像，处理字体资源，执行canvas绘制等等，但是好在有线程的第三方库，html2canvas，可以很大程度上减少工作量，同时也是通过了单元测试与经过时间的验证的，用的也比较放心，可以将精力放在其他问题上
>
> 将canvas转换为blob，由于Clipboard API不支持直接将base64字符串写入，必须要转换为blob封装为ClipboardItem才可以使用，然后再通过navigator.clipboard.write写入剪贴板
>
> blob表示为一种不可变的，原始数据的类文件对象，blob可以包含文本，图像，适视频等各种类型的数据，而我们的fileapi实际上就是拿到的blob数据，严格意义上来讲blob并非流数据，但是他们可以相互转换。
>
> 在得到canvas对象后，通过调用toBlob的方法可以得到blob数据，然后将blob封装为ClipboardItem写入剪切板，同时还存在着一些其他的限制需要解决
>
> 一些注意事项
>
> 1 Clipboard API兼容型问题，图片格式的支持比较差，最好使用png格式
>
> 2 Clipboard API只能在https的环境下使用
>
> 3 blob并非为流数据，只是可以根流数据相互转换，blob不可改变，可以表示二进制数据，也可以通过slice切割形成新的blob，可以将blob转换为readableStream进行流的操作

# 虚拟列表

>为了更好的展示商品数据，降低页面卡顿，针对商品列表采用了虚拟滚动的方式动态的去展示相应的数据。
>
>1 列表每一项定宽高
>
>需要计算的信息：
>
>可视区域高度固定screenHeight
>
>1 列表总高度：列表项 * 每一项的高度
>
>2 可显示的列表数：Math.ceil(可视区域的高度/每一项的高度)
>
>3 起始索引：当前滚动的位置/每一项的高度
>
>4结束索引：起始索引+可显示的列表数
>
>5偏移量：当前滚动的位置-（当前滚动的位置 % 每一项的高度）避免显示不全   注：外层容器位置是固定的，内层的可视区域和总列表容器会随着滚动事件向上下偏移，但是我们必须把可视区域留在容器内，于是需要计算偏移量
>
>监听滚动事件去实时计算起始与结束索引和偏移量即可
>
>有了这些数据定宽高的虚拟列表就很好做了
>
>2 不定宽高
>
>在不定高的情况下，那么上面的某些属性的计算就没有那么容易了
>
>就涉及到这么几个问题
>
>1 如何获取列表项的真实高度
>
>2 设计列表项高度的计算应该怎么修改
>
>我们可以采用预估高度的方式，预估一个高度渲染出来真实的dom，然后再update周期中根据真实的dom去调整真实的高度，所以我们需要创建一个缓存数据列表记录相关数据，一开始以预估的数据进行渲染，等真实dom渲染完毕后再去获取真实的dom数据，去替换缓存列表中的预估高度数据同时更新后续全部列表项的top和botom值（放在update生命周期中同时采用nextTick去保证真实dom更新完成） 
>
>根据缓存列表重新获取响应的数据  缓存列表（每一项的索引，高度，距离顶部的位置，距离底部的位置）后续dom渲染完成后在更新即可
>
>总高度：列表项最后一项的bottom
>
>可视区域的数量：可视区域的高度（固定的）/预估的每一项的高度（只计算近似即可，无需准确）
>
>偏移量：取第一个可见元素的上一个元素的bottom即可
>
>开始索引，以前定高时用高度/每一项的高度以及不行了，现在需要在缓存列表中找到第一个底部定位大于列偏移量的项，并且返回索引（由于是有序列表，最开始采用的find变为了使用二分法的方式去找），结束索引的计算保持不变（开始索引+可视区域显示的数量） 
>
>那么仍然存在两个问题 白屏闪烁与滚动事件触发频繁的问题
>
>3 针对白屏闪烁
>
>白屏闪烁的原因呢是因为用户滚动过快，但是dom的渲染需要一定的时间，于是出现了白屏闪烁的情况
>
>可以增加上下两个缓冲区，给滚动事件更新视图留出充足的时间，增加一个比例，用来记录缓冲区数据与可视区数据的一个比例，也就是计算出缓冲区缓冲多少条数据，同时渲染的数据与偏移量也需要考虑到上下缓冲区的情况，特别要注意，当列表在最顶部的时候不存在上缓冲区，在最底部的时候不存在下缓冲区
>
>4 滚动事件频发的问题
>
>将滚动事件换成IntersectionObserver，去监听列表项是否进入可视区域





网页